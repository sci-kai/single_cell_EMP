---
title: "D19200 - preprocessing"
author: "Kai"
date: "13th January 2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load packages}
library(Seurat)
library(ggplot2)
library(grid)
library(ggrepel)
library(MAST)
library(RColorBrewer)
library(scales)

#create theme to not duplicate code
theme_jb <- function(base_size=11) {
  (theme_bw() +
     theme(
       axis.title = element_text(size=11),
       axis.text = element_text(size=11),
       legend.text = element_text(size=11),
       #optional rotation of x-axis labels
       axis.text.x = element_text(angle=90, hjust=1,vjust=.5)
     ))
}

theme_jb_nogrid <- function(base_size=11) {
  (theme_bw() +
     theme(
       axis.title = element_text(size=11),
       axis.text = element_text(size=11),
       legend.text = element_text(size=11),
       #optional rotation of x-axis labels
       axis.text.x = element_text(angle=90, hjust=1,vjust=.5),
       panel.grid = element_blank(),
       panel.border = element_blank(),
       axis.line = element_line()
     ))
}
```

# Load files and convert to Seurat

```{r load files}
#Folder where OUTPUT from script is saved
OUTPUT = "~/tscr/kai/projects/01_SCC_scRNA/results/samples/cohort/D19200/rp/"
#Folder of cellranger output
data_dir = "~/tscr/Allgemeine Daten/10x Genomics/data/14405_firstSCC/cellrangerouts_hg38/outs/"

#raw data containing gene expression
D19200.data <- Read10X(paste0(data_dir,"raw_feature_bc_matrix/"))
#Setup Seurat Object for gene Expression
D19200 <- CreateSeuratObject(D19200.data, project = "D19200")
#remove raw data input
rm(D19200.data)
```

# Quality control and Filtering

## Assign the percentage of mitochondrial gene expression and number of expressed housekeeper genes

houskeeping genes are e.g. ribosomal proteins, expressed in nearly every cell and less sensitive to high dropout.

```{r}
# relative expression of mitochondrial gene as metric for damaged cells
D19200[["percent.mito"]] <- PercentageFeatureSet(D19200, pattern = "^MT-") 

#read in names of housekeeper genes from Tirosh paper
hkgenes <- read.table("~/tscr/kai/projects/01_SCC_scRNA/db/tirosh_house_keeping.txt", skip = 2)
hkgenes <- as.vector(hkgenes$V1) 
# remove hkgenes that were not found (maybe not in the reference or got lost)
hkgenes.found <- which(toupper(rownames(D19200)) %in% toupper(hkgenes))
# sum of hk genes for each cell
hk_per_cell <- Matrix::colSums(GetAssayData(D19200)[hkgenes.found, ] > 0)
D19200 <- AddMetaData(object = D19200, metadata = hk_per_cell, col.name = "n.exp.hkgenes")
rm(hk_per_cell,hkgenes.found)
```

## Quality Control

We create a central dataframe with all quality metrices for every cell for easier plotting

```{r calculate sequence summary}
CreateBarcodeMetrics <- function (seuratobject,hkgenes) {
  #Add HK and MITO expression to all  
  seuratobject[["percent.mito"]] <- PercentageFeatureSet(seuratobject, pattern = "^MT-") 
  hkgenes.found <- which(toupper(rownames(seuratobject)) %in% toupper(hkgenes))
  hk_per_cell <- Matrix::colSums(GetAssayData(seuratobject)[hkgenes.found, ] > 0)
  seuratobject <- AddMetaData(object = seuratobject, metadata = hk_per_cell, col.name = "n.exp.hkgenes")
  data.frame(barcodes=names(seuratobject$nCount_RNA),
                                 nCount =  seuratobject$nCount_RNA,
                                 nFeature = seuratobject$nFeature_RNA,
                                 percent.mito = seuratobject$percent.mito,
                                 n.exp.hkgenes = seuratobject$n.exp.hkgenes)
}

barcode_metrics <- CreateBarcodeMetrics(D19200,hkgenes)

head(barcode_metrics)
```

Than we have four metrices to identify barcodes containing live and usable cells:
* UMI counts (nCount)
* Gene counts (nFeature)
* Mitochondrial gene expression: % of UMIs in mitochondrial genes relative to all genes
* Housekeeper genes: Number of housekeeping genes (97 in total) that have at least 1 UMI count in a cell (no percentage)

It is not helpful to look at all metrics independently since they correlating a lot with each other. So first, the correlations between the metrices are investigated.

### Filter quality metric dataframe for definitely empty barcodes to get readable histograms

First, in this helping dataframe we filter out cells that are definitely empty barcodes since they have only few UMI Counts. These are normally around 70-90% of all barcodes and will give us more informative histograms in downstream processing (Otherwise there will always be a very high peak at around zero). 
To examine distribution over all barcodes, we do a cumulative plot showing the % of cells with less than a certain amount of Counts

```{r cumplot}
cumplotdata <- data.frame(x=1:1000, y= unlist(lapply(1:1000,function(x) sum(D19200$nCount_RNA < x) / length(D19200$nCount_RNA < x))))

cumplot.log10 <- ggplot() + 
  geom_point(data=cumplotdata,
             aes(x=log10(x),y=y)) +
  ggtitle("% of barcodes that are lower than x Counts") +
  scale_y_continuous(breaks=seq(0,1,0.1)) +
  #coord_cartesian(ylim=c(0.5,1)) +
  theme_bw()

cumplot.log10
```

Based on the previous plot we do the actual filtering for around 90% of the cells that are definitely empty in the helping dataframe
```{r}
nCount_lowest <- 5
barcode_metrics <- barcode_metrics[barcode_metrics$nCount > nCount_lowest,]
```

### Create Functions for standard QC plots

```{r}
PlotUMIvsGENE <- function(barcode_metrics,col,colname,xintercept=NA,yintercept=NA,title=NULL) {
  ggExtra::ggMarginal(ggplot(data=barcode_metrics)+ 
                        geom_point(aes(x=log10(nCount),
                                       y=log10(nFeature),
                                       col=col),
                                   alpha=.5) + 
                        {if(!is.na(xintercept)) geom_vline(xintercept = xintercept)} +
                        {if(!is.na(yintercept)) geom_hline(yintercept = yintercept)} +
                        {if(!is.null(title)) ggtitle(title)} +
                        scale_x_continuous(breaks=seq(0,10,0.5)) +
                        scale_y_continuous(breaks=seq(0,10,0.5)) +
                        labs(col=colname) +
                        theme_bw() +
                        theme(legend.position = "bottom"),
                      type="densigram", bins=100)
}

PlotUMIvsMITO <- function(barcode_metrics,col,colname,xintercept=NA,yintercept=NA,title=NULL) {
  ggExtra::ggMarginal(ggplot(data=barcode_metrics) + 
                        geom_point(aes(x=log10(nCount),
                                       y=percent.mito,
                                       col=col),
                                   alpha=0.5) + 
                        {if(!is.na(xintercept)) geom_vline(xintercept = xintercept)} +
                        {if(!is.na(yintercept)) geom_hline(yintercept = yintercept)} +
                        {if(!is.null(title)) ggtitle(title)} +
                        scale_x_continuous(breaks=seq(0,10,0.5)) +
                        scale_y_continuous(breaks=seq(0,100,5), limits = c(0,100)) +
                        labs(col=colname) +
                        theme_bw() +
                        theme(legend.position="bottom"),
                      type="densigram",
                      xparams = list(bins=100),
                      yparams = list(binwidth=1))
}

PlotUMIvsHK <- function(barcode_metrics,col,colname,xintercept=NA,yintercept=NA,title=NULL) {
  ggExtra::ggMarginal(ggplot(data=barcode_metrics) + 
                        geom_point(aes(x=log10(nCount),
                                       y=n.exp.hkgenes,
                                       col=col),
                                   alpha=0.5) + 
                        {if(!is.na(xintercept)) geom_vline(xintercept = xintercept)} +
                        {if(!is.na(yintercept)) geom_hline(yintercept = yintercept)} +
                        {if(!is.null(title)) ggtitle(title)} +
                        scale_x_continuous(breaks=seq(0,10,0.5)) +
                        scale_y_continuous(breaks=seq(0,100,5),limits = c(0,100)) +
                        labs(col=colname) +
                        theme_bw() +
                        theme(legend.position="bottom"),
                      type="densigram",
                      xparams = list(bins=100),
                      yparams = list(binwidth=1))
}

PlotHKvsMITO <- function(barcode_metrics,col,colname,xintercept=NA,yintercept=NA,title=NULL) {
  ggExtra::ggMarginal(ggplot(data=barcode_metrics) + 
                        geom_point(aes(x=n.exp.hkgenes,
                                       y=percent.mito,
                                       col=col),
                                   alpha=0.5) + 
                        {if(!is.na(xintercept)) geom_vline(xintercept = xintercept)} +
                        {if(!is.na(yintercept)) geom_hline(yintercept = yintercept)} +
                        {if(!is.null(title)) ggtitle(title)} +
                        scale_y_continuous(breaks=seq(0,100,5),limits = c(0,100)) +
                        scale_x_continuous(breaks=seq(0,100,5),limits = c(0,100)) +
                        labs(col=colname) +
                        theme_bw() +
                        theme(legend.position="bottom"),
                      type="densigram",
                      xparams = list(binwidth=1),
                      yparams = list(binwidth=1))
}
```

### Examine: UMI counts vs Gene counts

UMI and gene counts are highly correlated with each other. It is not possible to have more genes than counts (since every gene need at least one UMI count).

```{r UMIvsGENE}
UMIvsGENE.mito <- PlotUMIvsGENE(barcode_metrics = barcode_metrics,
                                col = barcode_metrics$percent.mito,
                                colname = "percent.mito")
UMIvsGENE.hk <- PlotUMIvsGENE(barcode_metrics = barcode_metrics,
                              col = barcode_metrics$n.exp.hkgenes,
                              colname = "n.exp.hkgenes")

ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-filtering-UMIvsGENE-mito.svg"),UMIvsGENE.mito)
ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-filtering-UMIvsGENE-hk.svg"),UMIvsGENE.hk)
```

### Examine: mitochondrial gene expression and housekeeper genes vs Counts

```{r mitandhkvsumi}
UMIvsMITO.hk <- PlotUMIvsMITO(barcode_metrics = barcode_metrics,
                              col = barcode_metrics$n.exp.hkgenes,
                              colname = "n.exp.hkgenes")
UMIvsHK.mito <- PlotUMIvsHK(barcode_metrics = barcode_metrics,
                            col = barcode_metrics$percent.mito,
                            colname = "percent.mito")

ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-filtering-UMIvsMITO-hk.svg"),UMIvsMITO.hk)
ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-filtering-UMIvsHK-mito.svg"),UMIvsHK.mito)
```

## Filtering Counts and Features

In general we want to examine all quality metrices and have a special look at certain populations of barcodes in there and want to assign thresholds in that way that these populations are still in there. Good practice here is to have a very permissive filtering first and re-evaluate the filtering after downstream-processing to be more strict.

Rules of Thumb for Filtering:

* for first filtering, be as permissive as possible to not exclude a certain cell population
* Do *not* decide your filtering strategy by looking only on one quality metrics alone - these metrices depend a lot from each other, use the above plots to examine what cut-offs are reasonable. Further downstream, Filtering will be evaluated more in detail.
* First, we only filter for Counts and Features, than repeat QC and set the thresholds for mitochondrial/housekeeper gene expression. This enables better peak identification especially in mitochondrial gene expression, so that more permissive filtering of mitochondrial gene expression combined with housekeeper gene expression is possible.

```{r}
#Cut-offs
#Here you put in your respective cut-off. If you do not want to use a certain cut-off, comment out the respective line in the subsetting command AND the barcode_metrics assignment and set the value to NA
nCount_low <- 500
nCount_high <- NA
nFeature_low <- NA
nFeature_high <- NA

#Subset Seurat object
D19200.filt <- subset(D19200,
                       nCount_RNA > nCount_low
                       #& nCount_RNA < nCount_high
                       #& nFeature_RNA > nFeature_low 
                       #& nFeature_RNA < nFeature_high
)

#assign which barcodes were kept in filtering
barcode_metrics$countfiltering <- NA
barcode_metrics[barcode_metrics$nCount > nCount_low
                  #barcode_metrics$nCount < nCount_high & 
                  #barcode_metrics$nFeature > nFeature_low &
                  #barcode_metrics$nFeature < nFeature_high &
                  ,]$countfiltering <- "cell" 
barcode_metrics[!(barcode_metrics$nCount > nCount_low
                  #barcode_metrics$nCount < nCount_high & 
                  #barcode_metrics$nFeature > nFeature_low &
                  #barcode_metrics$nFeature < nFeature_high &
                  ),]$countfiltering <- "background"
```

### Examine: mitochondrial gene expression and housekeeper genes vs Counts

```{r mitandhkvsumi-cf}
UMIvsMITO.cf.hk <- PlotUMIvsMITO(barcode_metrics = barcode_metrics[barcode_metrics$countfiltering=="cell",],
                              col = barcode_metrics[barcode_metrics$countfiltering=="cell",]$n.exp.hkgenes,
                              colname = "n.exp.hkgenes")
UMIvsHK.cf.mito <- PlotUMIvsHK(barcode_metrics = barcode_metrics[barcode_metrics$countfiltering=="cell",],
                            col = barcode_metrics[barcode_metrics$countfiltering=="cell",]$percent.mito,
                            colname = "percent.mito")

ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-filtering-UMIvsMITO-countfilt-hk.svg"),UMIvsMITO.cf.hk)
ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-filtering-UMIvsHK-countfilt-mito.svg"),UMIvsHK.cf.mito)
```

### Examine: mitochondrial gene expression vs housekeeper genes

Usually, barcodes with high mitochondrial gene expression and low housekeeper gene expression are regarded as dying cells or cells undergoing large oxidative stress.

```{r mitvshk-cf}
HKvsMITO.cf.UMI <- PlotHKvsMITO(barcode_metrics = barcode_metrics[barcode_metrics$countfiltering=="cell",],
                             col = log10(barcode_metrics[barcode_metrics$countfiltering=="cell",]$nCount),
                             colname = "nCount_log10")

ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-filtering-HKvsMITO-countfilt-UMI.svg"),HKvsMITO.cf.UMI)
```

## Filtering with mitochondrial and housekeeper genes

```{r}
percent.mito_high <- 10
n.exp.hkgenes_low <- NA

#make sure, you also enable the nCount and Feature filter here!
D19200.filt <- subset(D19200,
                       nCount_RNA > nCount_low
                       #& nCount_RNA < nCount_high
                       #& nFeature_RNA > nFeature_low 
                       #& nFeature_RNA < nFeature_high
                       & percent.mito < percent.mito_high 
                       #& n.exp.hkgenes > n.exp.hkgenes_low
)

#assign which barcodes were kept in filtering
barcode_metrics$manualfiltering <- NA
barcode_metrics[barcode_metrics$nCount > nCount_low &
                #barcode_metrics$n.exp.hkgenes > n.exp.hkgenes_low & 
                barcode_metrics$percent.mito < percent.mito_high 
                #barcode_metrics$nCount < nCount_high & 
                #barcode_metrics$nFeature > nFeature_low &
                #barcode_metrics$nFeature < nFeature_high &
                ,]$manualfiltering <- "cell" 
barcode_metrics[!(barcode_metrics$nCount > nCount_low &
                  #barcode_metrics$n.exp.hkgenes > n.exp.hkgenes_low & 
                  barcode_metrics$percent.mito < percent.mito_high
                  #barcode_metrics$nCount < nCount_high & 
                  #barcode_metrics$nFeature > nFeature_low &
                  #barcode_metrics$nFeature < nFeature_high &
                  ),]$manualfiltering <- "background"
```

After filtering for those, we examine what is filtered and whats not filtered.

### Examine: UMI counts vs gene counts after filtering

```{r umivsgene-afterfilt}
#All barcodes, colored by filtered cells with minimum count and feature numbers
UMIvsGENE.filt <- PlotUMIvsGENE(barcode_metrics = barcode_metrics,
                                col = barcode_metrics$manualfiltering,
                                colname = "cells filtered", 
                                xintercept = log10(c(nCount_low,nCount_high)), 
                                yintercept = log10(c(nFeature_low,nFeature_high))) 

#only cell barcodes, colored by percent.mito
UMIvsGENE.cells.mito <- PlotUMIvsGENE(barcode_metrics[barcode_metrics$manualfiltering == "cell",],
                                      col = barcode_metrics[barcode_metrics$manualfiltering == "cell",]$percent.mito,
                                      colname = "percent.mito",
                                      xintercept = log10(c(nCount_low,nCount_high)),
                                      yintercept = log10(c(nFeature_low,nFeature_high)))

# only NOT cells
UMIvsGENE.notcells.mito <-  PlotUMIvsGENE(barcode_metrics[barcode_metrics$manualfiltering != "cell",],
                                      col = barcode_metrics[barcode_metrics$manualfiltering != "cell",]$percent.mito,
                                      colname = "percent.mito",
                                      xintercept = log10(c(nCount_low,nCount_high)),
                                      yintercept = log10(c(nFeature_low,nFeature_high)))

ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-filtering-UMIvsGENE-filt.svg"),UMIvsGENE.filt)
ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-filtering-UMIvsGENE-cells-mito.svg"),UMIvsGENE.cells.mito)
ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-filtering-UMIvsGENE-notcells-mito.svg"),UMIvsGENE.notcells.mito)
```

### Examine: mitochondrial gene expression and housekeeper genes vs Counts after filtering

```{r mitandhkvsumi-afterfilt}
#all barcodes, colored by cells
UMIvsMITO.filt <-  PlotUMIvsMITO(barcode_metrics = barcode_metrics,
                                 col = barcode_metrics$manualfiltering,
                                 colname = "cells filtered",
                                 xintercept = log10(c(nCount_low,nCount_high)),
                                 yintercept = percent.mito_high)
#only cells
UMIvsMITO.cells.hk <-  PlotUMIvsMITO(barcode_metrics = barcode_metrics[barcode_metrics$manualfiltering == "cell",],
                                     col = barcode_metrics[barcode_metrics$manualfiltering == "cell",]$n.exp.hkgenes,
                                     colname = "n.exp.hkgenes",
                                     xintercept = log10(c(nCount_low,nCount_high)),
                                     yintercept = percent.mito_high) 
#only not cells
UMIvsMITO.notcells.hk <-  PlotUMIvsMITO(barcode_metrics = barcode_metrics[barcode_metrics$manualfiltering != "cell",],
                                        col = barcode_metrics[barcode_metrics$manualfiltering != "cell",]$n.exp.hkgenes,
                                        colname = "n.exp.hkgenes",
                                        xintercept = log10(c(nCount_low,nCount_high)),
                                        yintercept = percent.mito_high) 

#all barcodes, colored by cells
UMIvsHK.filt <-  PlotUMIvsHK(barcode_metrics = barcode_metrics,
                             col = barcode_metrics$manualfiltering,
                             colname = "cell",
                             xintercept = log10(c(nCount_low,nCount_high)),
                             yintercept = n.exp.hkgenes_low)
#only cells
UMIvsHK.cells.mito <- PlotUMIvsHK(barcode_metrics = barcode_metrics[barcode_metrics$manualfiltering == "cell",],
                                  col = barcode_metrics[barcode_metrics$manualfiltering == "cell",]$percent.mito,
                                  colname = "percent.mito",
                                  xintercept = log10(c(nCount_low,nCount_high)),
                                  yintercept = n.exp.hkgenes_low) 

#only not cells
UMIvsHK.notcells.mito <- PlotUMIvsHK(barcode_metrics = barcode_metrics[barcode_metrics$manualfiltering != "cell",],
                                  col = barcode_metrics[barcode_metrics$manualfiltering != "cell",]$percent.mito,
                                  colname = "percent.mito",
                                  xintercept = log10(c(nCount_low,nCount_high)),
                                  yintercept = n.exp.hkgenes_low) 

ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-filtering-UMIvsMITO-filt.svg"),UMIvsMITO.filt)
ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-filtering-UMIvsMITO-cells-hk.svg"),UMIvsMITO.cells.hk)
ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-filtering-UMIvsMITO-notcells-hk.svg"),UMIvsMITO.notcells.hk)
ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-filtering-UMIvsHK-filt.svg"),UMIvsHK.filt)
ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-filtering-UMIvsHK-cells-mito.svg"),UMIvsHK.cells.mito)
ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-filtering-UMIvsHK-notcells-mito.svg"),UMIvsHK.notcells.mito)
```

### Examine: percent.mito vs n.exp.hkgenes after filtering

```{r HKvsMITO-afterfilt}
#all barcodes, colored by filtering
HKvsMITO.filt <- PlotHKvsMITO(barcode_metrics = barcode_metrics,
                              col = barcode_metrics$manualfiltering,
                              colname = "cell",
                              xintercept = n.exp.hkgenes_low,
                              yintercept = percent.mito_high)

#only cells, colored by nCounts
HKvsMITO.cells.UMI <- PlotHKvsMITO(barcode_metrics = barcode_metrics[barcode_metrics$manualfiltering == "cell",],
                                   col = log10(barcode_metrics[barcode_metrics$manualfiltering == "cell",]$nCount),
                                   colname = "nCount_log10",
                                   xintercept = n.exp.hkgenes_low, 
                                   yintercept = percent.mito_high)

#only NOT cells, colored by nCounts
HKvsMITO.notcells.UMI <- PlotHKvsMITO(barcode_metrics = barcode_metrics[barcode_metrics$manualfiltering != "cell",],
                                   col = log10(barcode_metrics[barcode_metrics$manualfiltering != "cell",]$nCount),
                                   colname = "nCount_log10",
                                   xintercept = n.exp.hkgenes_low, 
                                   yintercept = percent.mito_high)

ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-filtering-HKvsMITO-filt.svg"),HKvsMITO.filt)
ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-filtering-HKvsMITO-cells-UMI.svg"),HKvsMITO.cells.UMI)
ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-filtering-HKvsMITO-notcells-UMI.svg"),HKvsMITO.notcells.UMI)
```

# Normalization

The Seurat object is structured in assays, and each assay has three slots containing the actual gene expression matrix:

* slot "counts": raw count matrix
* slot "data": Log-normalized gene expression matrix
* slot "scale.data": scaled data (mean centered and scaled to standard deviation of each feature). Optional, variables can be regressed in this step.

In the beginning, we only have the "RNA" assay and, very important to know, all three slots contain the raw count matrix!
After Normalization of the RNA assay, the slot contain the proper normalized data.

# Normalization of RNA assay

Additionally, sets most variable features.

```{r}
#log-normalization for slot "data"
D19200.filt <- NormalizeData(D19200.filt, 
                               normalization.method = "LogNormalize", #default
                               scale.factor = 10000, #default, scale factor 10000 is recommendation from seurat tutorial
                               assay = "RNA",
                               margin = 1 # default; normalizes across features
) 

#Find Variable Features
D19200.filt <- FindVariableFeatures(D19200.filt, 
                                      assay = "RNA",
                                      selection.method = "vst", #default
                                      nfeatures = 2000 #default; only 2000 , 3000 for SCT promises since to "restore" some more VariableFeatures
)

#scaling for slot "scale.data" by ALL genes, not only most variable ones
allgenes <- rownames(D19200.filt)
D19200.filt <- ScaleData(D19200.filt, 
                           features = allgenes, 
                           do.scale = T,
                           do.center = T,
                           scale.max = 10, #maximum value for scaling standard deviation, can cause that means are not exactly zero (https://github.com/satijalab/seurat/issues/1166)
                           assay = "RNA")
```

# Normalization using SCTransform

based on the Seurat Tutorial from SCTransform, there can be a benefit of using more PC's in downstream analysis since the normalization regresses out more technical variation. Therefore, also set most variable features for SCT assay.
https://satijalab.org/seurat/v3.1/sctransform_vignette.html

```{r}
D19200.filt <- SCTransform(D19200.filt, 
                           ncells=5000, #default  
                           assay="RNA", #default
                           new.assay.name = "SCT", #default
                           do.correct.umi = T, #default change counts slot to corrected counts in new assay
                           variable.features.n = 3000, #default set variable features
                           vars.to.regress = NULL, #default optional variables to regress out
                           do.scale = F, #default scale pearson residuals in scale.data slot to have unit variance
                           do.center = T, #default center pearson residuals in scale.data to have mean zero, needed for PCA
                           return.only.var.genes = T, #default scale.data.matrices output assay only contains variable genes
                           seed.use = 1448145)
```

# Dimensionality Reduction and Clustering

## Principal Component Analysis (first 50 PCs)

In general, I would recommend to read the general Seurat Tutorial about this:
https://satijalab.org/seurat/articles/pbmc3k_tutorial.html#perform-linear-dimensional-reduction-1 

Also, in this Dimensional Reduction Vignette you can find some more information about PCA:
https://satijalab.org/seurat/articles/dim_reduction_vignette.html

PCA Calculation and Plot
```{r PCA, fig.height=6, fig.width=6}
D19200.filt <- RunPCA(D19200.filt,
                      npcs = 50, 
                      assay = "SCT",
                      rev.pca = F, # default, Run cell x gene matrix
                      weight.by.var = T, #default, Weight cell embedding by variance of each PC
                      approx = T, #if TRUE, uses irlba instead of prcomp, which is a single value decomposition to approximate PCs, saving computation time (by not calculating all PCs; important for big datasets) and being similar to PCs. Beware, that approx=F has an error in calculating PCs in optimized Seurat version!
                      features = VariableFeatures(D19200.filt,assay = "SCT"), #default
                      reduction.name = "pca_SCT",
                      verbose = F)
```

Elbowplot

```{r PCA_elbow}
#Variance explained of each PC in % (0 to 100)
#in older Seurat versions, the total variance calculated and stored in PCA Dimred object is the total variance ONLY of the most variable genes that were used for PCA, not for the whole dataset!
PCAvar.SCT <- D19200.filt@reductions$pca_SCT@stdev^2 / sum(matrixStats::rowVars(as.matrix(D19200.filt@assays$SCT@scale.data)[VariableFeatures(D19200.filt,assay = "SCT"),]))

#PCA Plot
PCAplot.SCT <- DimPlot(D19200.filt, reduction = "pca_SCT", dims = c(1,2),group.by = "orig.ident") + 
  labs(x=paste0("principal component 1 (",signif(PCAvar.SCT[1]*100,digits = 2),"% of variance)"),
       y=paste0("principal component 1 (",signif(PCAvar.SCT[2]*100,digits = 2),"% of variance)"))

#Heatmap of genes across principal component with highest loadings
PCAheatmap.SCT <- DimHeatmap(D19200.filt,
                             dims = 1:20, 
                             balanced = T,
                             fast=F,
                             reduction = "pca_SCT",
                             assays = "SCT",
                             slot = "scale.data")

# elbow plot
PCAelbowplot.SCT <- ggplot(data=data.frame(var=PCAvar.SCT,
                                           PC=1:length(PCAvar.SCT))[1:50,]) +
  geom_point(mapping = aes(x=PC,y=var)) +
  labs(x="principal Component", y="% of Variance") +
  scale_x_continuous(breaks=seq(0,50,5)) +
  theme_bw()

# cumulative variance plot
PCAsumplot.SCT <- ggplot(data=data.frame(cumvar=cumsum(PCAvar.SCT),PC=1:length(PCAvar.SCT))[1:50,]) +
  geom_point(mapping = aes(x=PC,y=cumvar)) +
  labs(x="principal Component", y="% of cumulative Variance") +
  scale_x_continuous(breaks=seq(0,50,5)) +
  theme_bw()

ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-all-SCT-PCA.svg"),PCAplot.SCT)
ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-all-PCA-heatmap.svg"),PCAheatmap.SCT, height=15)
ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-all-SCT-PCA-elbow.svg"),PCAelbowplot.SCT)
ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-all-SCT-PCA-variancesum.svg"),PCAsumplot.SCT)

PCAplot.SCT
PCAheatmap.SCT
PCAelbowplot.SCT
PCAsumplot.SCT
```

## Graph-based Clustering

We examine based on the Elbowplot how many PC's should be used for clustering and UMAP. Should be a consistent value capturing most variance, so best to choose some PC's after the elbow is flattening. With the Heatmap one can estimate whether PC's capture biological meaningful variation or technical noise at a certain PC.
Recommended default is around 15-30 PC's.

```{r FindClusters}
numberofPCs = 20

D19200.filt <- FindNeighbors(object = D19200.filt,
                             dims = 1:numberofPCs,
                             reduction = "pca_SCT",
                             assay = "SCT")
D19200.filt <- FindClusters(D19200.filt,
                            resolution = 0.8,
                            random.seed = 100)

# replot PCA plot with cluster
PCAplot.SCT.clus <- DimPlot(D19200.filt, reduction = "pca_SCT", dims = c(1,2),group.by = "seurat_clusters") + 
  labs(x=paste0("PC1 (",signif(PCAvar.SCT[1]*100,digits = 2),"% of variance)"),
       y=paste0("PC2 (",signif(PCAvar.SCT[2]*100,digits = 2),"% of variance)"))

ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-all-SCT-PCA-clus.svg"),PCAplot.SCT.clus)

PCAplot.SCT.clus
```

## UMAP

```{r UMAP, fig.width=10, fig.height=8}
D19200.filt <- RunUMAP(D19200.filt,
                              dims = 1:numberofPCs,
                              assay = "SCT",
                              umap.method = "uwot", #default
                              graph=NULL, #default
                              reduction="pca_SCT",
                              reduction.name = "umap_SCT")

UMAP.SCT.clus <- DimPlot(D19200.filt, 
                         reduction = "umap_SCT", 
                         pt.size = 1, 
                         label = T, 
                         group.by = "seurat_clusters") + theme(legend.position = "bottom")
ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-all-SCT-UMAP-clus.svg"),UMAP.SCT.clus)
UMAP.SCT.clus
```

## Quality control for clusters

### Quality metrics 

```{r}
D19200.filt$nCount_RNA_log10 <- log10(D19200.filt$nCount_RNA)
D19200.filt$nFeature_RNA_log10 <- log10(D19200.filt$nFeature_RNA)

VLN.QC <- VlnPlot(object = D19200.filt,
                  features = c("nFeature_RNA_log10", "nCount_RNA_log10", "percent.mito", "n.exp.hkgenes"),
                  ncol = 2,
                  pt.size = 0.1,
                  group.by = "seurat_clusters")
UMAP.SCT.QC <- FeaturePlot(object = D19200.filt,
                           features = c("nFeature_RNA_log10", "nCount_RNA_log10","percent.mito", "n.exp.hkgenes"),
                           reduction = "umap_SCT",
                           ncol = 2,
                           pt.size = 0.5)

ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-all-VLN-clusterQC.svg"),VLN.QC, height=15, width=10)
ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-all-SCT-UMAP-clusterQC.svg"),UMAP.SCT.QC)

VLN.QC
UMAP.SCT.QC
```

# Cell type identification

## Marker gene expression

Manual Annotation based on marker gene expression

Source for Immune markers: https://doi.org/10.1038/s41467-019-12464-3
CD4+: T- helper cell
CD8+: cytotoxic T-Cells

Important: takes Default assay for expression values(check with DefaultAssay())

```{r FeatPlot_T-cellmarker}
#define function for plotting and saving
FeaturePlot_celltype <- function(genes,filesuffix) {
  markerplot <- FeaturePlot(D19200.filt, 
              features = genes, 
              cols = c("grey", "blue"),
              reduction = "umap_SCT",
              slot = "data")
  ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-all-SCTdata-UMAP-markers-",filesuffix,".svg"),markerplot)
  markerplot
}

#General T-Cell markers
FeaturePlot_celltype(c("CD4","CD8A","CD8B","CD3E","CD3D","CD3G"),"TCells")

#FOR CD4+ T-Cells
#T-Cell naive or TCM cells
FeaturePlot_celltype(c("CCR7","SELL","TCF7"),"TCellCD4-Naive")
#T-Cell activation markers
FeaturePlot_celltype(c("IL2","TNF","IL4R"),"TCellCD4-activated")
#TRM-like resting and activating clusters
FeaturePlot_celltype(c("CXCR6","ITGA1"),"TCellCD4-TRMlikeResting")
#Regulatory T-cells
FeaturePlot_celltype(c("FOXP3","IL2RA","CTLA4"),"TCellCD4-TReg")

#For CD8+ T-Cells
# TEM/TRM-like clusters (with cytotoxicity associated GZMB/GZMK, TRM markers CXCR6, ITGA1)
FeaturePlot_celltype(c("CCL5","GZMB","GZMK","CXCR6","ITGA1"),"TCellCD8-TEM")
#activated  TRm/TEM cluster
FeaturePlot_celltype(c("IFNG","CCL4","CCL3"),"TCellCD8-activeTRM")
#TEMRA (terminally differentiated effector cells)
FeaturePlot_celltype(c("PRF1","NKG7"),"TCellCD8-TEMRA")
#T-Cell exhaustion markers
FeaturePlot_celltype(c("PD-1","LAG3","CD8B"),"TCellCD8-exhausted")

#Classical Monocytes /tissue macrophages
FeaturePlot_celltype(c("CD14","LYZ","CD68","CD74", "HLA-DQA1"),"Monocytes-tissueMacrophages")
#Non-classical monocytes
FeaturePlot_celltype(c("FCGR3A","CSTB"),"Monocytes-nonclassical")
#NK cells
FeaturePlot_celltype(c("GNLY","NKG7","CD16"),"NKcells")
#B Cells
FeaturePlot_celltype(c("CD79A","CD74"),"BCells")
#Dendritic cells/ b cell
FeaturePlot_celltype(c("CD74","HLA-DQA1","FCN1","LYZ"),"DendriticCells")
#Platelets
FeaturePlot_celltype(c("PPBP","ITGA2B"), "platelets")
#Red Blood Cells
FeaturePlot_celltype(c("HBA1"),"RBC")
#Fibroblasts
FeaturePlot_celltype(c("FAP", "TAGLN", "VIM","ACTA2", "VCL","PDGFRB","FN1", "CAV1", "COL1A1"), "Fibroblasts")
#Others
FeaturePlot_celltype(c("FCER1A", "VWF","PPBP", "MS4A1", "IL7R","CD19","CSF1R", "CD163"), "OtherMarkers")
#epithelial markers
FeaturePlot_celltype(c(paste0("KRT",c("6A","6B","6C","14","16","DAP")),"S100A7","S100A8","S100A9","FABP5"),"epithelial")
#pEMT markers
FeaturePlot_celltype(c("KRT15","MMP1","MMP10","MMP13","FOS","FOSB","CXCL14","MT2A","CAV1","THBS1"),"pEMT")
```

## Celltype Annotation

```{r umap-celltype}
Idents(D19200.filt) <- D19200.filt$seurat_clusters

D19200.filt <- RenameIdents(D19200.filt,
                    "0" = "Tumor",
                    "1" = "Dendritic Cells",
                    "2" = "Tumor",
                    "3" = "Tumor",
                    "4" = "Fibroblasts",
                    "5" = "Tumor",
                    "6" = "Macrophages",
                    "7" = "Fibroblasts",
                    "8" = "Fibroblasts",
                    "9" = "Tumor",
                    "10" = "Fibroblasts",
                    "11" = "Endothelial Cells"
                    )

D19200.filt$CellType <- Idents(D19200.filt)

#new UMAP
UMAP.SCT.celltype <- DimPlot(D19200.filt,
                             reduction = "umap_SCT", 
                             pt.size = 1, 
                             label = T, 
                             group.by = "CellType") + theme(legend.position = "none")
#for figure
UMAP.SCT.celltype <- UMAP.SCT.celltype + theme_jb_nogrid()

ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-all-SCT-UMAP-celltype.svg"),UMAP.SCT.celltype, width=5, height=5)
ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-all-SCT-UMAP-celltype-noleg.svg"),UMAP.SCT.celltype + theme(legend.position = "none") + ggtitle(NULL), width=5, height=5)

UMAP.SCT.celltype
```

## Quality control for celltypes

### Quality metrics 

```{r}
D19200.filt$nCount_RNA_log10 <- log10(D19200.filt$nCount_RNA)
D19200.filt$nFeature_RNA_log10 <- log10(D19200.filt$nFeature_RNA)

VLN.QC.celltype <- VlnPlot(object = D19200.filt, 
                           features = c("nFeature_RNA_log10", "nCount_RNA_log10", "percent.mito", "n.exp.hkgenes"), 
                           ncol = 2,  
                           pt.size = 0.1)

ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-all-VLN-celltypeQC.svg"),VLN.QC.celltype, height=15, width=10)

VLN.QC.celltype
```

#UMAPs for expression of VIM, KRT6B and KRT17

```{r}
VIM.umap <- FeaturePlot(D19200.filt, 
                        features = "VIM", 
                        cols = c("grey95", "blue"),
                        order = T,
                        reduction = "umap_SCT",
                        slot = "data") +
  theme_jb_nogrid()

ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-all-SCTdata-UMAP-VIM.svg"),VIM.umap, width=3.33, height=3.33)
ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-all-SCTdata-UMAP-VIM-noleg.svg"),VIM.umap + theme(legend.position = "none") + ggtitle(NULL), width=3.33, height=3.33)

KRT6B.umap <- FeaturePlot(D19200.filt, 
              features = "KRT6B", 
              cols = c("grey95", "blue"),
              order = T,
              reduction = "umap_SCT",
              slot = "data") +
  theme_jb_nogrid()

ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-all-SCTdata-UMAP-KRT6B.svg"),KRT6B.umap, width=3.33, height=3.33)
ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-all-SCTdata-UMAP-KRT6B-noleg.svg"),KRT6B.umap + theme(legend.position = "none") + ggtitle(NULL), width=3.33, height=3.33)

KRT17.umap <- FeaturePlot(D19200.filt, 
              features = "KRT17", 
              cols = c("grey95", "blue"),
              order = T,
              reduction = "umap_SCT",
              slot = "data") +
  theme_jb_nogrid()

ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-all-SCTdata-UMAP-KRT17.svg"),KRT17.umap, width=3.33, height=3.33)
ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-all-SCTdata-UMAP-KRT17-noleg.svg"),KRT17.umap + theme(legend.position = "none") + ggtitle(NULL), width=3.33, height=3.33)
```

# Differential Expression

As recommended by Seurat FAQ, we should use the RNA assay and NOT the pearson residuals of the SCT assay (inside of "scale.data" slot) https://github.com/satijalab/seurat/discussions/4032.

*Slot to use*
It is default and recommended to use the "data" slot of either RNA assay or SCT assay, since the counts are corrected for the sequencing depth. 
Mostly the log Foldchange is used in downstream analysis. The log Foldchange depends on the used slot! 
It is also to note, that the pct.1 and pct.2 values change if you use the RNA or SCT assay.

*Test to use*
Standard method is to use "wilcox". I use MAST since it is also recommended by Theis et al. (https://doi.org/10.15252/msb.20188746) and performs well in a general single cell DE review https://doi.org/10.1038/nmeth.4612, that was recommended in the Seurat tutorial. The test does not create as inflated p-values as with wilcox test.

*PCT option*
The general review also recommends a min.pct of 25%, but since this only excludes genes from testing, I would rather recommend the default of 0.1 to not miss too many information.

```{r}
Idents(D19200.filt) <- NA
Idents(D19200.filt) <- D19200.filt$CellType

#Differential expression of every cluster against all other cluster
D19200.filt.marker <- FindAllMarkers(D19200.filt,
                                      assay = "RNA",
                                      slot="data", 
                                      test.use = "MAST", #alternative recommendation: MAST
                                      random.seed=1,
                                      logfc.threshold = 0, #shows the test results of all tested genes
                                      min.pct=0.1, #default; prior filtering of tested genes applied!
                                      latent.vars=NULL) # default; only for regression methods
```

# Volcano Plots 

## Volcano Plotting function

```{r}
ggvolcanopct <- function(data,logFCthres) {
  logFCthres_low <- logFCthres[1]
  logFCthres_up <- logFCthres[2]
  ggplot(data = data,
         aes(x=avg_log2FC,
             y=pct.1-pct.2,
             col=pct.1-pct.2>logFCthres_up | pct.1-pct.2<logFCthres_low)) + 
    geom_point() + 
    geom_text_repel(aes(label=ifelse(pct.1-pct.2>logFCthres_up | pct.1-pct.2<logFCthres_low,as.character(data$gene),"")),
                    max.overlaps = 100) +
    scale_color_manual(values = c("TRUE"="red", "FALSE"="grey")) +
    scale_x_continuous(breaks=seq(-10,10,0.5)) +
    scale_y_continuous(breaks=seq(-1,1,0.1)) +
    coord_cartesian(ylim = c(-1,1), xlim=c(-max(abs(c(min(data$avg_log2FC),max(data$avg_log2FC))))-0.1,max(abs(c(min(data$avg_log2FC),max(data$avg_log2FC))))+0.1)) + #symmetric x-axis and y-axis with short buffer
    geom_hline(yintercept = 0, col="black", size=0.1) +
    geom_vline(xintercept = 0, col="black", size=0.1) +
    theme_jb() +
    theme(legend.position = "none", panel.grid.minor = element_blank())
}

ggvolcanopctpos <- function(data,logFCthres) {
  data <- data[data$avg_log2FC>0,]
  logFCthres_up <- logFCthres[2]
  ggplot(data = data,
         aes(x=avg_log2FC,
             y=pct.1-pct.2,
             col=pct.1-pct.2>logFCthres_up)) + 
    geom_point() + 
    geom_text_repel(aes(label=ifelse(pct.1-pct.2>logFCthres_up,as.character(data$gene),"")),
                    max.overlaps = 100) +
    scale_color_manual(values = c("TRUE"="red", "FALSE"="grey")) +
    scale_x_continuous(breaks=seq(0,10,0.5)) +
    scale_y_continuous(breaks=seq(-1,1,0.1)) +
    coord_cartesian(ylim = c(0,1), xlim=c(0,max(abs(c(min(data$avg_log2FC),max(data$avg_log2FC))))+0.1)) + #symmetric x-axis and y-axis with short buffer
    theme_jb() +
    theme(legend.position = "none", panel.grid.minor = element_blank())
}
```

## Create Volcano Plots

```{r}
#set thres function for selecting genes to mark in volcano plot
#take top and bottom 20 genes
thres_func_plot = function(x) {
  c(sort(D19200.filt.marker[D19200.filt.marker$cluster==x,]$pct.1 - D19200.filt.marker[D19200.filt.marker$cluster==x,]$pct.2, decreasing = F)[21], 
    sort(D19200.filt.marker[D19200.filt.marker$cluster==x,]$pct.1 - D19200.filt.marker[D19200.filt.marker$cluster==x,]$pct.2, decreasing = T)[21])
}

#create volcano plots with pct difference on y-axis
D19200.filt.marker.volpct <- lapply(levels(D19200.filt.marker$cluster), function(x) ggvolcanopct(D19200.filt.marker[D19200.filt.marker$cluster==x,],thres_func_plot(x)) + ggtitle(x))
names(D19200.filt.marker.volpct) <- levels(D19200.filt.marker$cluster)

#save volcano plots
for (i in names(D19200.filt.marker.volpct)) {
  ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-all-diffexpr-volcanopct-",i,".svg"),D19200.filt.marker.volpct[[i]],width=5, height=5)
}

#only positive log2FC
#create volcano plots with pct difference on y-axis
D19200.filt.marker.volpctpos <- lapply(levels(D19200.filt.marker$cluster), function(x) ggvolcanopctpos(D19200.filt.marker[D19200.filt.marker$cluster==x,],thres_func_plot(x)) + ggtitle(x))
names(D19200.filt.marker.volpctpos) <- levels(D19200.filt.marker$cluster)

#save volcano plots
for (i in names(D19200.filt.marker.volpctpos)) {
  ggsave(filename = paste0(OUTPUT,"figs-D19200/D19200-all-diffexpr-volcanopctpos-",i,".svg"),D19200.filt.marker.volpctpos[[i]],width=5, height=5)
}
```

```{r}
D19200.filt.marker.volpct
```

```{r}
D19200.filt.marker.volpctpos
```

#Save Output

```{r}
#save Seurat Object
save(file = paste0(OUTPUT,"RData/D19200-filt.RData"),D19200.filt)
save(file = paste0(OUTPUT,"RData/D19200-all-diffexpr-marker.RData"),D19200.filt.marker)
#sessioninfo
writeLines(capture.output(sessionInfo()), paste0(OUTPUT,"RData/01-D19200-all-sessionInfo.txt"))
```
